<!DOCTYPE html>
<html>
<head>
    <title>WebGL Button</title>
    <style>
        canvas {
            border: 1px solid black;
            cursor: pointer;
            transition: filter 0.2s;
        }

        canvas:hover {
            filter: brightness(1.1);
        }

        canvas:active {
            transform: scale(0.98);
        }
    </style>
</head>
<body>
<canvas id="glCanvas" width="200" height="60"></canvas>

<script>
    const canvas = document.getElementById('glCanvas');
    const gl = canvas.getContext('webgl');
    let isActive = false;

    // Вершинный шейдер
    const vsSource = `
            attribute vec2 aPosition;
            void main() {
                gl_Position = vec4(aPosition, 0.0, 1.0);
            }
        `;

    // Фрагментный шейдер
    const fsSource = `
            precision mediump float;
            uniform vec3 uColor;
            void main() {
                gl_FragColor = vec4(uColor, 1.0);
            }
        `;

    // Инициализация шейдеров
    const vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertexShader, vsSource);
    gl.compileShader(vertexShader);

    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, fsSource);
    gl.compileShader(fragmentShader);

    const shaderProgram = gl.createProgram();
    gl.attachShader(shaderProgram, vertexShader);
    gl.attachShader(shaderProgram, fragmentShader);
    gl.linkProgram(shaderProgram);
    gl.useProgram(shaderProgram);

    // Вершины для прямоугольника
    const vertices = new Float32Array([
        -1, -1,
        1, -1,
        -1, 1,
        1, 1
    ]);

    const vertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

    const aPosition = gl.getAttribLocation(shaderProgram, "aPosition");
    gl.enableVertexAttribArray(aPosition);
    gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);

    // Получаем uniform-переменную для цвета
    const uColor = gl.getUniformLocation(shaderProgram, "uColor");

    function render() {
        gl.clearColor(0, 0, 0, 1);
        gl.clear(gl.COLOR_BUFFER_BIT);

        // Меняем цвет в зависимости от состояния
        const color = isActive ? [1.0, 0.0, 0.0] : [0.0, 0.5, 1.0];
        gl.uniform3fv(uColor, color);

        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        requestAnimationFrame(render);
    }

    // Обработчики событий
    canvas.addEventListener('click', () => {
        isActive = !isActive;
        // Здесь можно добавить логику при клике
        console.log('Canvas clicked!');
    });

    // Запуск рендеринга
    render();
</script>
</body>
</html>